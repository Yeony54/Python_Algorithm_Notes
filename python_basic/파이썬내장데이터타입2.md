#####  Python Built-in Data Type

##  2. Sequence

- 순서가 있는 자료형 (자료구조)
- `<class list>`
- `<class tuple>`
- `<class range>`



list, tuple, range는 기능적인 면에서 비슷하다.

list에서 전반적인 기능을 알아보고 이어서 tuple, range를 설명한다.

이번 글은 좀 길다. Python을 처음 접해보았다면 자료구조 설명은 뛰어넘고, '이렇게 쓰는구나' 정도를 알면된다.



---



### Python : List

##### <list 생성 예시>

```python
a = []                   # empty list
a = list()			     # empty list
a = [1, 2, 3, 4]
a = [1, 2, 3.14]         # 다른 데이터 타입도 혼용 가능
a = [1, 2, [3, 4], 5]    # list도 원소로 가질 수 있음
```

이전 포스팅인 Numeric Data Type에 대해서 알아볼 때 Python의 자료구조에 대해 잠깐 설명했다.

List 생성을 자료구조와 함께 알아본다면 더욱 깊이 있는 이해가 될것이다.

하지만 필수로 필요하진 않기 때문에, Python을 처음 접하는 사람이라면 Python활용방법만 익혀도 충분하다.





##### <List 자료구조 설명>

> list는 `a = []` 이나 `a = list()` 로 생성할 수 있다.
>
> 실행하면 메모리에 `a`라는 이름의 공간이 생성되고,
>
> `[]`나 `list()`를 통해 `<class list>`를 호출하여 객체로 공간이 할당되고 `주소`를 배정받게 된다. 
>
> `a`에는 `list의 주소`가 저장되게 된다.
>
> 이로서 `a`를 호출하게 된다면 `a`에 저장된 `list의 주소`를 따라 `list`를 호출할 수 있게 된다.
>
> > `a = [1, 2, 3, 4]`처럼 list를 생성할 때 주어진 데이터가 있다면,
> >
> > 데이터의 수만큼 list에 공간을 할당 받고 각 공간마다 위의 과정처럼 데이터가 저장되게 된다.



##### <자료구조 관련 함수>

이하의 내용을 이해하려면 앞서 설명한 자료구조에 대한 이해가 필요하다.

- Python의 숫자 객체 공간 공유
  - 숫자 객체는` 0 ~ 256` 까지의 범위는 같은 객체를 공유한다.
- `id()`
  - 메모리의 주소값에 대한 hash값을 알려준다.

```python
a = 100                     
b = 100
print(id(a))                      # 결과 140735944141664
print(id(b))                      # 결과 140735944141664

a = list()
b = list()
print(id(a))                      # 결과 3106780842048
print(id(b))                      # 결과 3106780843072
```

Python은 자주사용하는 숫자 `0 ~ 256`범위의 객체를 공유하도록 설계하였다.

그래서 첫번째 예제에서 다른 변수의 값이라도 같은 주소의 hash값이 출력되는것을 확인할 수 있다.

오직 숫자 `0 ~ 256`에 한해서만 객체 공유를 허용하였기 때문에,

예제 2번과 같이 같은 `empty list` 라도 다른 주소의 hash 값이 출력되는 것을 확인할 수 있다.





---





#### Python : List indexing, slicing

**index**란 list 내에 존재하는 공간의 순서라고 생각하면 된다.

위에서 언급한것과 같이 list는 생성될 때, 인자로 주어진 데이터 수만큼의 공간을 할당받게된다. 

이 공간의 첫번째 index는 `0`이고 이후 `1, 2, 3... `으로 배정받는다.

또한, 마지막 index부터 `-1`을 시작하여 `-2, -3, -4...` 로도 호출할 수 있다.

이는 Python에서만 가능한 index방식이며, 사진을 보고 이해하면 쉽다.



- 사진



##### <Python : list indexing 예제>

```python
a = [1, 2, 3, [4, 5], 6]

print(a[0])                 # 결과 1
a[0] = 100	                # a[0]을 100으로 수정
print(a[0])                 # 결과 100

print(a[3][0])              # 결과 4
# print(a[5])               # Error : a의 마지막 index는 4이다.

print(a[-2])                # 결과 [4, 5]
```

##### 예제 설명

`a[0]` 를 출력하게 되면 `a` 의 index 0번째인 `1`이 출력된다.

`a[0]`번쨰의 값을 100으로 수정한 뒤 `a[0]`를 출력하게 되면 수정된 `100`이 출력된다.

`a[3][0]`를 출력하게 되면 `a`의 index 3번째인 `[4, 5]`의 index 0번째 `4`가 출력된다.

`a[-2]`를 출력하게 되면 뒤에서 두번째인 `[4, 5]`가 출력된다. 

`a`에서 `a[3]`와 `a[-2]`는 같은 위치임을 알 수 있다.





**slicing**은 주어진 index에 해당하는 부분집합을 만들어내는 것이다.

기본적으로 슬라이싱은 `[n1:n2]`의 형태로 주어지게되며,

시작 인덱스인 `n1`은 포함하고(inclusive) `n2`를 포함하지않는(exclusive)

`n1`번째부터 `n2`이전의 번지수 까지 추출하게 된다.

##### <Python : list slicing 예제>

```python
a = [1, 2, 3, [4, 5], 6]

print(a[1:3])               # 결과 [2, 3]
print(a[1:2])               # 결과 [2]

print(a[1:])                # 결과 [2, 3, [4, 5], 6]
print(a[:3])                # 결과 [1, 2, 3]
print(a[:])                 # 결과 [1, 2, 3, [4, 5], 6]
```

##### 예제 설명

`a[1:3]`는 `a`의 1번째 주소부터 3 이전의 주소까지인 `[2, 3]`을 출력한다.

`a[1:2]`는 `a`의 1번째 주소부터 2 이전의 주소까지인 `[2]`를 출력한다.

이때, slicing은 원본에서 부분집합을 구하는 것이기 때문에 `2`가 아닌 `[2]`, 원본과 동일한 데이터 타입이 나온다.

`[n1:n2]`형태에 `n1`이나 `n2`의 자리가 비어있다면, 끝까지라는 의미이다.

`a[1:]`는 `a`의 1번째 주소부터 끝까지인 `[2, 3, [4, 5], 6]`를 출력한다.

마찬가지로 `a[:3]`는 `[1, 2, 3]`를, `a[:]`는 `[1, 2, 3, [4, 5], 6]`를 출력한다.





---





#### Python : List의 연산

Python에서 `숫자 + 숫자`의 의미는 덧셈이다.

하지만 `List + List`에서의 의미는 다르다.



> **연산자 오버로딩** (operator overloading)
>
> 객체 지향 컴퓨터 프로그래밍에서 다형성의 특정 경우로 다른 연산자들이 함수 인자를 통해서 구현을 할 때를 말한다.



```python
a = [1, 2, 3]
b = [4, 5, 6]
print(a + b)                   # 결과 [1, 2, 3, 4, 5, 6]
```

만약 이렇게 제시되어 있는 상태에서 `a + b` list 끼리의 덧셈을 하게 된다면,

더하는 기호인 +의 피 연산자인 list로 인해 연산자의 의미가 변하는 **연산자 오버로딩**이 발생하게 된다.

 **연산자 오버로딩**이 발생하고, list에서는 연결의 의미로 바뀌어 `[1, 2, 3, 4, 5, 6]`의 결과가 출력되게 된다.



```python
print(a * 3)                  # 결과 [1, 2, 3, 1, 2, 3, 1, 2, 3]
```

또한 `n * m`에서 곱셈은 `n`을 `m`번 더한다는 의미를 가질 수 있기 때문에

위의 예제에서 `a`를 세번 더한 `[1, 2, 3, 1, 2, 3, 1, 2, 3]`가 출력된다.





----





#### Python : List 원소 추가

한번 생성된 리스트는 변경외에도 추가, 제거 등의 작업도 할 수 있다.

```python
a = list()                # empty list 생성
print(a)                  # 결과 []

a.append(10)              # 10 추가
print(a)                  # 결과 [10] 
a.append(20)              # 20 추가          
print(a)                  # 결과 [10, 20]
a.append(30)              # 30 추가          
print(a)                  # 결과 [10, 20, 30]

a.pop()                   # pop은 가장 마지막의 원소를 제거
print(a)                  # [10, 20]
a.pop(0)                  # index를 주어 index의 원소 제거 가능
print(a)                  # [20]
```

 



---





#### Python : List 정렬

list의 값을 정렬할 수 있는 함수로`sort()`와 `sorted()`를 사용할 수 있다.

기본 정렬은 오름차순 정렬이며, 이는 인자를 주어 내림차순, 사용자 정의 순으로 지정할 수 있다.

`sort()` 를 사용한 정렬은 원본만 정렬하고 결과값을 만들어내지 않기 때문에 주의해야한다.

`sorted()`를 사용한 정렬은 원본은 유지하고 정렬된 복사본을 만든다.

```python
a = [4, 7, 10, 2, 8, 1, 9]

result = a.sort()
print(result)                      # 결과 None (값이 없음)

result = sorted(a)
print(a)                           # 결과 [4, 7, 10, 2, 8, 1, 9]
print(result)                      # 결과 [1, 2, 4, 7, 8, 9, 10]
```





---





### Python : Tuple

튜플은 `()`의 기호나 `tuple()`을 통해 생성된다.

이전의 list 의 생성방법과 비슷하다.

##### <tuple 생성 방법 예제>

```python
a = (1, 2, 3)
a = ()               # empty tuple
a = tuple()          # empty tuple

print(type(a))       # 결과 <class 'tuple'>

a = (1, 2, 3, (4, 5), 6) # 중첩 tuple
a = [1, 2, (3, 4), 5]    # 가능
a = (1, 2, [3, 4], 5)    # 가능
```



##### <tuple indexing, slicing>

```python
a = (1, 2, 3)

print(a[1])             # indexing 결과 2
print(a[1:3])           # slicing 결과 (2, 3)

# a[0] = 100            # Error

a = (1, 2, [3, 4], 5)
a[2][0] = 100
print(a)
```

tuple은 list와 마찬가지로 indexing, slicing을 할 수 있다.

하지만 tuple은 read only이기 때문에 원소를 변경할수 없다.

> tuple의 자료구조 설명
>
> 생성된 tuple에 저장된 객체의 주소를 바꾸지 못한다.

tuple에 저장된 객체의 주소를 바꾸지 못하지만, 원소 중 list가 있다면 다르다.

tuple에 저장된 list의 주소는 유지하되, list 내에서의 주소만 바뀌기 때문이다.



##### <tuple 연산 예제>

```python
a = (1, 2, 3)
b = (4, 5, 6)
print(a + b)              # 결과 (1, 2, 3, 4, 5, 6)
```

tuple의 연산은 list에서와 같이 `+`기호가 연결의 의미를 갖는다.



##### <tuple과 list>

```python
a = [1, 2, 3]
b = tuple(a)
print(b)             # 결과 (1, 2, 3)

a = (1, 2, 3)
b = list(a)
print(b)             # 결과 [1, 2, 3]
```

`tuple()`함수에 `list`인자를 넣거나, `list()`함수에 `tuple`인자를 넣어 생성할 수 있다.



-------



### Python : range

앞서 얘기한 list와 tuple은 여러개의 데이터를 방을 이용해 저장하는 자료구조로 실제 데이터를 가지고있다.

반면, range는 숫자만 표현할 수 있으며, 실제 데이터를 가지지 않는다.

range는 `range(초기값, 마지막값, 증가값)`으로 표현되며, 초기값부터 마지막값까지 증가값거리만큼 증가하는 sequence를 표현한다.

##### <range 사용 예시 1>

```python
a = range(0, 10, 1)    # 0,1,2,3,4...9
print(a)               # range(0, 10)
```



> list, tuple의 경우 1000000개의 데이터를 가지고 있으면 실제 메모리 양도 데이터의 개수만큼 필요하다.
>
> 하지만 range는 실제 데이터가 아닌 의미만을 저장하기 때문에 작은 메모리 공간으로 큰 수를 표현 가능하다.



##### <range 사용 예시 2>

```python
a = range(10)          # range(0,10,1)
print(a)               # range(0, 10)
```

range는 보통 `range(초기값, 마지막값, 증가값)` 중에 초기값과 증가값을 생략할 수 있다. 

`range(10)`을 출력하면 `range(0,10,1)`과 같은것을 확인할 수 있다.



##### <range 사용 예시 3 : indexing slicing>

```python
a = range(10,50,1)

print(a[1])           # 11
print(a[5:10])        # range(15,20)
```

range는 indexing과 slicing도 가능하다.

